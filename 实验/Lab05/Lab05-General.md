# Lab05: Linux 进程管理

[TOC]

## 1. 实验目的

- 了解进程的相关知识
- 能够使用fork、exec函数族、wait、exit等函数创建新进程并管理进程
- 能够使用重定向实现读写文件
- 能够使用管道实现进程间通信

## 2. 实验内容

- 创建并终止僵尸进程
- 使用fork和wait函数创建进程并等待进程结束
- 使用exec函数族调用可执行程序
- 使用重定向完成文件输入输出
- 使用管道完成进程间通信

## 3. 实验指南

### 3.1. 进程

进程的英文是`process`，意为“做事情的过程”，操作系统中的进程就可以理解为“**操作系统执行一个程序的过程**”。

程序在编译后以二进制方式存在于外存上，执行的时候被操作系统载入内存。以 Linux 系统上的 C 语言编译出来的程序为例，载入的过程简单来说就是把编译完成的 ELF 文件的几个段的内容读取到内存指定位置，然后初始化寄存器的内容，将指令寄存器（比如`cs:ip`）指向程序入口，再初始化一些进程相关内容就完成了。在某一次时钟中断发生的时候，进程主动陷入内核态，进行进程切换的系统调用，CPU 将切换到另一个进程工作（关于具体的进程切换的细节是大家下学期学习操作系统的重点）。**总而言之，整个计算机从开机到关机，就是一个不断创建、切换、终止进程的过程。**

#### 3.1.1. 进程概念的用途

- 早期的计算机一次只能执行一个程序，这种程序完全控制系统，并且访问所有系统资源。

- 相比之下，现代计算机系统允许“同时”加载多个应用程序到内存，以便并发（轮流）执行。

- 这种改进要求：对各种程序提供更严的控制和更好的划分。这些需求导致了**进程**概念的诞生。

- 进程是现代分时操作系统的工作单元，是操作系统向运行中的程序进行资源分配的单位。

- 进程包括：程序代码(文本)，当前活动(程序计数器，寄存器的值)，堆栈，数据端，堆。

    ![process](Lab05.assets/process.jpg)

- 程序与进程：程序是被动(`passive`)实体，如存储在磁盘上的可执行文件；进程是活动(`active`)实体，具有一个程序计数器用于表示下个执行命令和一组相关资源。

- 当一个可执行文件被加载到内存时，这个程序就成为进程。

- 两个进程可以与同一程序相关联，但当作两个单独的执行序列，虽然文本段相同，但是数据、堆、堆栈不同。

#### 3.1.2. 进程状态（选读）

- 进程在执行时会改变状态，每个进程可能处于以下状态：

    - 新的(`new`)：进程正在创建。
    - 运行(`running`)：指令正在执行。
    - 等待(`waiting`)：进程等待发生某个事件（如`I/O`完成或收到信号）。
    - 就绪(`ready`)：进程等待分配处理器。
    - 终止(`terminated`)：进程已经完成执行。

- 一次只有一个进程可在一个处理器上**运行**(`running`)

- 可以有多个进程处于**就绪**(`ready`)或**等待**(`waiting`)状态

- 进程状态图：

    ![进程状态图](Lab05.assets/process_status.jpg)

#### 3.1.3. PCB（选读）

对于多任务处理系统，一般来讲，CPU 核心数远低于当前系统中同时存在的进程数，因此，某一时刻，大概率总有一些进程处于非运行时状态。但这些进程在未来的一些时刻又将会被调度执行，恢复到之前该进程被终止时候的状态。因此，有必要把一个进程被终止时的信息记录下来。这些信息被称为进程控制块 PCB（Process Control Block），主要包括进程被终止时各个寄存器的使用情况、父进程 ID、进程组 ID 等。操作系统可以通过进程的 ID，找到该进程的 PCB。

PCB 可能包含的信息有：

- 进程状态(`process state`)：包括上面提到的五种状态。

- 程序计数器(`program counter`)：表示进程将要执行的下个指令的地址。

- CPU 寄存器(`CPU register`)：根据计算机体系结构的不同，寄存器的类型和数量也会不同，通常包括累加器、索引寄存器、堆栈指针、通用寄存器和其他条件码寄存器。在发生中断时，这些状态信息与程序计数器一起保存，以便进程以后能正确地继续执行。

- CPU 调度信息(`CPU-scheduling information`)：包括进程优先级、调度队列的指针和其他调度参数。

- 内存管理信息(`memory-management information`)：可能包括基地址和界限寄存器的值、页表或段表。

- 记账信息(`accounting information`)：包括 CPU 时间、实际使用时间、时间期限、记账数据、作业或进程数量等。

- I/O 状态信息(`I/O status information`)：包括分配给进程的`I/O`设备列表、打开文件列表等。

    ![PCB](Lab05.assets/pcb.jpg)

- 进程间的 CPU 切换：

    ![进程间的CPU切换](Lab05.assets/cpu_switch.jpg)

### 3.2. 进程控制

#### 3.2.1. 进程标识

- 每个进程都有一个非负整型表示的唯一进程 ID——`pid`。
- `pid`是可复用的，当一个进程终止后，其进程 ID 就成为复用的候选者。
- 除了`pid`，每个进程还有一些其他标识符，例如：`ppid`，`uid`，`euid`，`gid`，`egid`。

#### 3.2.2. 使用 `fork` 创建新进程

fork 的作用是创建一个子进程，共享父进程所有内容，并且这个子进程会接着 fork 下面的代码继续执行。关于 fork 的用法之类的不在赘述，下面探讨下 fork 的原理。fork 吹嘘的最神奇的地方莫过于执行一次，返回两次，但这句话噱头成分更大一些。在一个进程中，一次函数调用肯定只能返回一次，之所以 fork 会返回两次，是因为在 fork 执行的过程中，会根据本进程克隆出一个新的子进程，在子进程中依旧会执行 fork 剩余的代码，也自然会从 fork 中返回。这样，在父进程返回一次，在子进程中返回一次，自然就是所谓的“返回两次”。

![fork](Lab05.assets/fork.jpg)

```c
#include <unistd.h>

pid_t fork();

// 返回值：子进程返回0，父进程返回子进程ID；若出错，返回-1
```

- 一个现有的进程可以调用`fork`函数创建一个新进程。
- `fork`有以下两种用法：
    - 一个父进程希望复制自己，使父进程和子进程同时执行不同的代码段。
    - 一个进程要执行一个不同的程序。在这种情况下，子进程从`fork`返回后立即调用`exec`。

#### 3.2.3. 使用 exec 函数族执行新的程序

`exec()`函数族包括以下七个函数：

```c
#include <unistd.h>

int execl(const char *pathname, const char *arg0, ... /* (char *)0 */);

int execv(const char *pathname, char *const argv[]);

int execle(const char *pathname, const char *arg0, ...
          /* (char *)0, char *const envp[] */);

int execve(const char *pathname, char *const argv[], char *const envp[]);

int execlp(const char *filename, const char *arg0, ... /* (char *)0 */);

int execvp(const char *filename, char *const argv[]);

int fexecve(int fd, char *const argv[], char *const envp[]); // 第一个参数使用的是打开的文件描述符，而非文件路径名

// 7个函数返回值：若出错，返回-1；若成功，不返回
```

exec 函数族的作用是根据指定的文件名找到可执行文件，并用它来取代调用进程的内容换句话说，就是在调用进程内部执行一个可执行文件。这里的可执行文件既可以是二进制文件，也可以是任何 Linux 下可执行的脚本文件。与一般情况不同，exec 函数族的函数执行成功后不会返回，因为调用进程的实体，包括代码段，数据段和堆栈等都已经被新的内容取代，只留下进程 ID 等一些表面上的信息仍保持原样。只有调用失败了，它们才会返回一个 -1，从原程序的调用点接着往下执行。

这几个函数的用法大体上是一致的，只是参数格式有所不同。

- " l " 代表 list 即列表，对应可变参数`argv` 以列表的形式出现
- " v " 代表 vector 即矢量数组，对应可变参数`argv`以数组的形式出现
- " e " 代表 environment ，对应 `envp`数组，是指给可执行文件指定环境变量。在全部 7 个函数中，只有`execle`、`execve`和`fexecve`使用了`char *envp[]`传递环境变量，其它的 4 个函数都没有这个参数，这并不意味着它们不传递环境变量，这 4 个函数将把默认的环境变量不做任何修改地传给被执行的应用程序。而它们用指定的环境变量去替代默认的那些。
- " p " 代表 环境变量 PATH ,字母 p 是指在环境变量 PATH 的目录里去查找要执行的可执行文件。2 个以 p 结尾的函数`execlp`和`execvp`，看起来，和`execl`与`execv`的差别很小，事实也如此，它们的区别从第一个参数名可以看出：除 `execlp`和`execvp`之外的 4 个函数都要求，它们的第 1 个参数 path 必须是一个完整的路径，如"/bin/ls"；而`execlp`和`execvp` 的第 1 个参数 file 可以仅仅只是一个文件名，如"ls"，这两个函数可以自动到环境变量 PATH 指定的目录里去查找。

**注意：**

- 当进程调用一种`exec`函数时，该进程执行的程序完全替换为新程序，而新程序从其`main`函数开始执行。
- 调用`exec`并不创建新进程，前后的进程 ID 并未改变，`exec`只是用磁盘上的一个新程序替换了当前进程的正文段、数据段、堆段和栈段。
- 在很多 UNIX 实现中，**这`7`个函数只有`execve`是内核的系统调用**，另外`6`个只是库函数，它们最终都要调用该系统调用。

#### 3.2.4. 使用 exit 处理进程终止

```c
#include <stdlib.h>

void exit(int status);

void _Exit(int status);

#include <unistd.h>

void _exit(int status);
```

- 有`8`种方式使进程终止，其中`5`种为正常终止。
- `3`个函数用于正常终止一个程序：`_exit`和`_Exit`立即进入内核，`exit`则先执行一些清理处理，然后返回内核。

#### 3.2.5. 使用 `wait/waitpid` 等待进程终止

```c
#include <sys/wait.h>

pid_t wait(int *statloc);

pid_t waitpid(pid_t pid, int *statloc, int options);

// 两个函数返回值：若成功，返回进程ID；若出错，返回0或-1
```

更多信息请阅读`manual`或《APUE》的相关章节。

### 3.3. 进程间通信

这部分内容介绍的是操作系统内部的进程间的通信（Inter-Process Communication，IPC），主要包含管道通信、SystemV IPC（消息队列、信号量、共享内存等），不包含 socket 连接等系统之间的进程间的通信。

本次实验内容只涉及管道和重定向内容。

#### 3.3.1. 再谈重定向

在之前的思考题中，我们出现过 `dup` 函数，复制一个现存的文件描述符。事实上，文件描述符便与重定向密切关联。我们可以从 man 手册中了解 `dup`、`dup2` 和 `dup3()` 这三个函数。[dup(2) — Linux manual page](https://man7.org/linux/man-pages/man2/dup2.2.html)

重定向产生的原因就是文件描述符在分配时趋向于数值小的，而在用户层，stdout 这个文件指针指向的文件已经封装了，并且它的 fd 就是 1，这是不能修改的，所以我们一上来关闭了 1 号文件，然后新创建了一个文件它的文件描述符就会分配为被 1，同时此时写入时，像 `printf` 这类函数默认使用的输出流就是 stdout，但是我们知道它的 1 指向的已经是我们新生成的那个文件了，所以这就重定向的本质。

#### 3.3.2. 再谈管道

管道是最基本的进程通信机制，可以想象成一个管道，两端分别连着 2 个进程，一个进程往里面写，一个进程从里面读。如果读或写管道的时候没有内容可供读或写，进程将被阻塞，直到有内容可供读写为止。

管道分为匿名管道和命名管道。 匿名管道创建后本质上是 2 个文件描述符，父子进程分别持有就能够使用管道，需要注意的是不能够共用匿名管道，也就是除了使用的进程，其他进程需要关闭文件描述符，保证管道 的 2 个描述符分别同时只有 1 个进程持有。

命名管道是根据路径来使用管道，故能够在任意进程间通信。（仅要求掌握匿名管道，命名管道作为了解）

## 4. 实验习题

详见 Assignment 文件。