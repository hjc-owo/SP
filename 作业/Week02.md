# Week02 Assignment

> 姓名：胡峻诚
> 学号：19241027

*阅读教材第二章并查阅网络资料，回答以下问题。*

## 1. 安装 GCC、GDB、Make 工具，并查看各工具的版本。

你的系统是什么发行版？安装用什么命令？如何查看上述三个工具的版本？截图各工具的版本。

> 我的系统的发行版：Ubuntu 20.04.5 LTS
>
> 安装使用的命令：
>
> `sudo apt-get install gcc`
>
> `sudo apt-get install gdb`
>
> `sudo apt-get install make`
>
> 截图各工具的版本：
>
> ![Screenshot from 2022-09-05 19-56-21](https://raw.githubusercontent.com/hjc-owo/hjc-owo.github.io/img/202209052001353.png)

Hint：

- 根据你系统版本，你需要选择合适的安装指令，如 `apt` 或 `yum`
- 使用 `--version` 参数可以查看一个工具的版本

## 2. 练习使用 GCC。

编译过程有哪几个步骤？这些步骤分别用什么选项实现？

> 源代码 -> c文件 -> 汇编文件 -> 二进制文件 -> 可执行文件
>
> 1. 预处理：源代码 -> c文件：`gcc -E`
> 2. 编译工作：c文件 -> 汇编文件：`gcc -S`
> 3. 汇编工作：汇编文件 -> 二进制文件：`gcc -c`
> 4. 链接工作：二进制文件 -> 可执行文件：`gcc`

## 3. 静态链接库和动态链接库有何异同？如何生成？

> 相同点：
>
> 1. 共享代码
> 2. 代码封装
>
> 不同点：
>
> 1. 静态链接库：以.a为后缀。当要使用时，链接器会找出程序所需要的函数，然后将它们拷贝到可执行文件，由于这种拷贝是完整的，所以一旦链接成功，静态链接库也就不需要了。
> 2. 动态链接库：以.so为后缀。某个程序在运行中要调用某个动态链接库函数的时候，操作系统首先会查看所有正在运行的程序，看在内存中是否已经有此函数的拷贝了。如果有，则让其共享一个拷贝；否则，链接载入。在程序运行的时候，被调用的动态链接库函数被安置在内存的某个地方，所有调用它的程序将指向这个代码段。
>
> 如何生成：
>
> 生成静态库文件：使用`ar`命令，例如`ar rc libmycalc.a aver.o sum.o`
>
> 生成动态库文件：使用`gcc -shared`

## 4. 练习使用 GDB。

编写一个 C 程序，并自行调试，将关键步骤截图。

> 编写的C程序：
>
> ![Screenshot from 2022-09-05 20-34-26](https://raw.githubusercontent.com/hjc-owo/hjc-owo.github.io/img/202209052034486.png)
>
> GDB命令截图：
>
> ![Screenshot from 2022-09-05 20-38-47](https://raw.githubusercontent.com/hjc-owo/hjc-owo.github.io/img/202209052039442.png)

## 5. 练习使用 Make。

简述 `make` 工具的功能。

> 记录依赖关系并识别局部更新，是一个自动化的程序自动维护工具。

请阐述 `make` 如何确定哪些文件需要重新生成，而哪些不需要生成。

> 重新编译：
>
> 如果某个源程序文件被修改，那么依赖这个源程序文件的所有目标文件，都需要重新编译。包括：
>
> 1. 如果进修改了某几个源文件，则只重新编译这几个源文件
> 2. 如果某个头文件被修改了，则重新编译所有包含该头文件的源文件。
>
> 重新生成：
>
> 如果某个目标文件它所依赖的文件比它自身要新，那么目标就被认为是“过时”的，被认为是需要重新生成的，否则就不需要重新生成。

学习 `make` 的规则，并指出 Makefile 中 `.PHONY` 的作用。

> ```makefile
> target: prerequisites
> <TAB>	command
> ```
>
> target为目标，即make最终需要创建的文件，也可以是要执行的动作。
>
> prerequisites为一个或多个依赖文件列表。
>
> command为一系列命令，是make执行的动作，每个命令占一行，且每个命令行起始字符必须为TAB字符。
>
> 
>
> `.PHONY`表示伪目标，伪目标不代表一个真正的文件名，在执行make是可以指定这个目标来执行其所在规则定义的命令，作用是：
>
> 1. 避免在我们的Makefile中定义的只执行命令的目标（此目标的目的是为了执行一系列命令，而不需要创建这个目标）和工作目录下的实际文件名字出现冲突。
> 2. 提高执行make的效率，从而提高性能。

## 6. 实验准备

从下周开始，我们将进行系统编程的实验。一部分实验需要下载一些文件，我们将使用 `wget` 来下载。

### 6.1 安装 wget、unzip

你的系统使用什么指令安装？

> `sudo apt-get install wget`
>
> `sudo apt-get install unzip`

### 6.2 unzip 解压

使用什么指令解压一个名为 `practice.zip` 的压缩包？

> `unzip practice.zip`